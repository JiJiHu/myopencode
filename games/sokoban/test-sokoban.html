<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>æ¨ç®±å­æ¸¸æˆæµ‹è¯•</title>
</head>
<body>
    <h1>æ¨ç®±å­æ¸¸æˆä¿®å¤æµ‹è¯•</h1>
    <div id="test-results"></div>
    <div id="gameBoard" style="display:none;"></div>

    <script>
        // ç®€åŒ–çš„å…³å¡æ•°æ®ï¼ˆç”¨äºæµ‹è¯•ï¼‰
        const TEST_LEVELS = [
            [
                "#####",
                "#@! #",
                "# $ #",
                "#####"
            ]
        ];

        // ä»sokoban.htmlå¤åˆ¶çš„æ ¸å¿ƒä»£ç 
        let currentLevel = 0;
        let map = [];
        let playerPos = { x: 0, y: 0 };
        let moves = 0;
        let history = [];
        let isGameOver = false;
        let isPaused = false;
        let lastMoveTime = 0;
        const MOVE_COOLDOWN = 100;
        const MAX_HISTORY = 100;
        const SWIPE_THRESHOLD = 30;

        let lastRenderMap = null;
        let lastRenderPlayerPos = null;

        function parseLevel(levelIndex) {
            if (levelIndex < 0 || levelIndex >= TEST_LEVELS.length) {
                return null;
            }

            const levelData = TEST_LEVELS[levelIndex];
            if (!Array.isArray(levelData) || levelData.length === 0) {
                return null;
            }

            const newMap = [];
            let foundPlayer = false;
            let foundExit = false;

            for (let y = 0; y < levelData.length; y++) {
                const row = [];
                for (let x = 0; x < levelData[y].length; x++) {
                    const char = levelData[y][x];

                    if (char === '@') {
                        playerPos = { x, y };
                        foundPlayer = true;
                    }

                    if (char === '!') {
                        foundExit = true;
                    }

                    let tileValue = 0;
                    switch (char) {
                        case ' ': case '@': case '.': tileValue = 0; break;
                        case '#': tileValue = 1; break;
                        case '!': tileValue = 2; break;
                        case '$': tileValue = 3; break;
                        default: tileValue = 0;
                    }
                    row.push(tileValue);
                }
                newMap.push(row);
            }

            if (!foundPlayer || !foundExit) {
                return null;
            }

            return newMap;
        }

        function canMove(fromX, fromY, toX, toY) {
            if (toY < 0 || toY >= map.length || toX < 0 || toX >= map[0].length) {
                return false;
            }

            const targetTile = map[toY][toX];

            if (targetTile === 1) {
                return false;
            }

            if (targetTile === 3) {
                const boxToX = toX + (toX - fromX);
                const boxToY = toY + (toY - fromY);

                if (boxToY < 0 || boxToY >= map.length || boxToX < 0 || boxToX >= map[0].length) {
                    return false;
                }

                const boxToTile = map[boxToY][boxToX];

                if (boxToTile === 1 || boxToTile === 3) {
                    return false;
                }

                return { push: true, boxToX, boxToY };
            }

            return { push: false };
        }

        function movePlayer(dx, dy) {
            if (isGameOver || isPaused) return;

            const now = Date.now();
            if (now - lastMoveTime < MOVE_COOLDOWN) {
                return;
            }
            lastMoveTime = now;

            const fromX = playerPos.x;
            const fromY = playerPos.y;
            const toX = fromX + dx;
            const toY = fromY + dy;

            const result = canMove(fromX, fromY, toX, toY);
            if (!result) return;

            const historyEntry = {
                playerPos: { ...playerPos },
                changes: [
                    { x: fromX, y: fromY, oldValue: map[fromY][fromX], newValue: 0 }
                ],
                moves,
                pushed: false
            };

            playerPos.x = toX;
            playerPos.y = toY;

            if (map[fromY][fromX] === 2) {
                map[fromY][fromX] = 2;
            } else {
                map[fromY][fromX] = 0;
            }

            if (result.push) {
                historyEntry.pushed = true;

                const boxTargetOriginalValue = map[result.boxToY][result.boxToX];

                map[toY][toX] = 0;
                map[result.boxToY][result.boxToX] = 3;

                historyEntry.changes.push(
                    { x: result.boxToX, y: result.boxToY, oldValue: boxTargetOriginalValue, newValue: 3 }
                );
            }

            if (history.length >= MAX_HISTORY) {
                history.shift();
            }
            history.push(historyEntry);

            if (map[toY][toX] === 2) {
                isGameOver = true;
            }

            moves++;

            return true;
        }

        function undoMove() {
            if (history.length === 0) return false;

            const lastState = history.pop();

            playerPos = lastState.playerPos;

            for (const change of lastState.changes) {
                map[change.y][change.x] = change.oldValue;
            }

            moves = lastState.moves;
            isGameOver = false;

            return true;
        }

        function togglePause() {
            if (isGameOver) return false;
            isPaused = !isPaused;
            return isPaused;
        }

        function loadLevel(levelIndex) {
            const newMap = parseLevel(levelIndex);
            if (newMap) {
                map = newMap;
                moves = 0;
                history = [];
                isGameOver = false;
                isPaused = false;
                lastMoveTime = 0;
                lastRenderMap = null;
                lastRenderPlayerPos = null;
                return true;
            }
            return false;
        }

        // æµ‹è¯•å‡½æ•°
        function runTests() {
            const results = [];
            let passed = 0;
            let failed = 0;

            // æµ‹è¯•1: å…³å¡åŠ è½½
            results.push('<h2>æµ‹è¯•1: å…³å¡æ•°æ®éªŒè¯</h2>');
            const test1 = loadLevel(0);
            if (test1 && map.length > 0) {
                results.push('âœ… å…³å¡åŠ è½½æˆåŠŸ');
                passed++;
            } else {
                results.push('âŒ å…³å¡åŠ è½½å¤±è´¥');
                failed++;
            }

            // æµ‹è¯•2: å†å²è®°å½•é™åˆ¶
            results.push('<h2>æµ‹è¯•2: å†å²è®°å½•é™åˆ¶ï¼ˆæœ€å¤š100æ­¥ï¼‰</h2>');
            history = [];
            // æ¨¡æ‹Ÿç§»åŠ¨å¹¶æ£€æŸ¥å†å²è®°å½•
            for (let i = 0; i < 150; i++) {
                movePlayer(0, 0); // ä¸ç§»åŠ¨ï¼Œä½†æ·»åŠ å†å²è®°å½•
            }
            if (history.length <= MAX_HISTORY) {
                results.push('âœ… å†å²è®°å½•é™åˆ¶æ­£å¸¸ï¼ˆ' + history.length + 'æ­¥ï¼Œæœ€å¤š100æ­¥ï¼‰');
                passed++;
            } else {
                results.push('âŒ å†å²è®°å½•è¶…å‡ºé™åˆ¶');
                failed++;
            }

            // æµ‹è¯•3: ç§»åŠ¨å†·å´
            results.push('<h2>æµ‹è¯•3: ç§»åŠ¨å†·å´ï¼ˆ100msï¼‰</h2>');
            loadLevel(0);
            const move1 = movePlayer(1, 0);
            const move2 = movePlayer(1, 0);
            if (!move2) {
                results.push('âœ… ç§»åŠ¨å†·å´ç”Ÿæ•ˆï¼ˆå¿«é€ŸæŒ‰é”®è¢«é˜»æ­¢ï¼‰');
                passed++;
            } else {
                results.push('âŒ ç§»åŠ¨å†·å´æœªç”Ÿæ•ˆ');
                failed++;
            }

            // æµ‹è¯•4: æ’¤é”€åŠŸèƒ½
            results.push('<h2>æµ‹è¯•4: æ’¤é”€åŠŸèƒ½</h2>');
            loadLevel(0);
            setTimeout(() => {
                movePlayer(1, 0);
                const beforeUndo = moves;
                undoMove();
                if (moves < beforeUndo) {
                    results.push('âœ… æ’¤é”€åŠŸèƒ½æ­£å¸¸');
                    passed++;
                } else {
                    results.push('âŒ æ’¤é”€åŠŸèƒ½å¼‚å¸¸');
                    failed++;
                }

                // æµ‹è¯•5: æš‚åœåŠŸèƒ½
                results.push('<h2>æµ‹è¯•5: æš‚åœåŠŸèƒ½</h2>');
                const paused = togglePause();
                if (paused) {
                    const moveInPause = movePlayer(1, 0);
                    if (!moveInPause) {
                        results.push('âœ… æš‚åœåŠŸèƒ½æ­£å¸¸ï¼ˆæš‚åœæ—¶æ— æ³•ç§»åŠ¨ï¼‰');
                        passed++;
                    } else {
                        results.push('âŒ æš‚åœåŠŸèƒ½å¼‚å¸¸ï¼ˆæš‚åœæ—¶ä»å¯ç§»åŠ¨ï¼‰');
                        failed++;
                    }
                } else {
                    results.push('âŒ æš‚åœçŠ¶æ€åˆ‡æ¢å¤±è´¥');
                    failed++;
                }

                // æµ‹è¯•6: è§¦æ‘¸æ»‘åŠ¨é˜ˆå€¼
                results.push('<h2>æµ‹è¯•6: è§¦æ‘¸æ»‘åŠ¨é˜ˆå€¼ï¼ˆ30pxï¼‰</h2>');
                if (SWIPE_THRESHOLD === 30) {
                    results.push('âœ… æ»‘åŠ¨é˜ˆå€¼æ­£ç¡®ï¼ˆ30pxï¼‰');
                    passed++;
                } else {
                    results.push('âŒ æ»‘åŠ¨é˜ˆå€¼ä¸æ­£ç¡®');
                    failed++;
                }

                // æµ‹è¯•7: å¢é‡å¼æ¸²æŸ“å˜é‡
                results.push('<h2>æµ‹è¯•7: å¢é‡å¼æ¸²æŸ“</h2>');
                if (lastRenderMap !== null && lastRenderPlayerPos !== null) {
                    results.push('âœ… å¢é‡å¼æ¸²æŸ“å˜é‡å·²åˆå§‹åŒ–');
                    passed++;
                } else {
                    results.push('âŒ å¢é‡å¼æ¸²æŸ“å˜é‡æœªåˆå§‹åŒ–');
                    failed++;
                }

                // æµ‹è¯•8: å†å²è®°å½•ä¼˜åŒ–
                results.push('<h2>æµ‹è¯•8: å†å²è®°å½•ä¼˜åŒ–ï¼ˆåªè®°å½•å˜åŒ–ä½ç½®ï¼‰</h2>');
                loadLevel(0);
                setTimeout(() => {
                    movePlayer(1, 0);
                    if (history.length > 0 && history[0].changes && history[0].changes.length > 0) {
                        results.push('âœ… å†å²è®°å½•ä¼˜åŒ–æ­£å¸¸ï¼ˆåªè®°å½•' + history[0].changes.length + 'ä¸ªå˜åŒ–ä½ç½®ï¼‰');
                        passed++;
                    } else {
                        results.push('âŒ å†å²è®°å½•ä¼˜åŒ–å¼‚å¸¸');
                        failed++;
                    }

                    // æ±‡æ€»ç»“æœ
                    results.push('<h2>æµ‹è¯•æ±‡æ€»</h2>');
                    results.push('<p><strong>é€šè¿‡:</strong> ' + passed + '/8</p>');
                    results.push('<p><strong>å¤±è´¥:</strong> ' + failed + '/8</p>');

                    if (failed === 0) {
                        results.push('<h3 style="color:green;">ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼</h3>');
                    } else {
                        results.push('<h3 style="color:red;">âš ï¸ æœ‰ ' + failed + ' ä¸ªæµ‹è¯•å¤±è´¥</h3>');
                    }

                    document.getElementById('test-results').innerHTML = results.join('');
                }, 150);
            }, 150);
        }

        // è¿è¡Œæµ‹è¯•
        runTests();
    </script>
</body>
</html>
