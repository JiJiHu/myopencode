<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ğŸ´â€â˜ ï¸ æ•°ç‹¬å†’é™©</title>
    <link rel="stylesheet" href="../onepiece-theme.css">
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .close-btn {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.9);
            border: 2px solid #667eea;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            transition: all 0.3s;
        }

        .close-btn:hover {
            background: #667eea;
            color: white;
            transform: rotate(90deg);
        }

        .sudoku-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
        }

        .sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            gap: 0;
            border: 4px solid var(--onepiece-black);
            width: 500px;
            height: 500px;
            background: var(--onepiece-cream);
            box-shadow:
                0 8px 20px rgba(0,0,0,0.3),
                inset 0 2px 10px rgba(0,0,0,0.1);
        }

        .sudoku-cell {
            width: 50px;
            height: 50px;
            border: 1px solid #ccc;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
            user-select: none;
        }

        .sudoku-cell:hover {
            background: #f0f0f0;
        }

        .sudoku-cell.selected {
            background: #667eea !important;
            color: white !important;
        }

        .sudoku-cell.fixed {
            background: #e8e8e8;
            color: #333;
        }

        .sudoku-cell.error {
            background: #ffcccc;
            color: #cc0000;
        }

        .sudoku-cell.highlight {
            background: #e0e7ff;
        }

        .sudoku-cell:nth-child(3n) {
            border-right: 2px solid #333;
        }

        .sudoku-cell:nth-child(9n) {
            border-right: none;
        }

        .sudoku-cell:nth-child(n+19):nth-child(-n+27),
        .sudoku-cell:nth-child(n+46):nth-child(-n+54) {
            border-bottom: 2px solid #333;
        }

        .controls {
            margin-top: 20px;
            text-align: center;
            color: #666;
        }

        .numpad {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 20px;
            max-width: 300px;
        }

        .numpad button {
            padding: 15px;
            font-size: 20px;
            font-weight: bold;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: #667eea;
            color: white;
            transition: background 0.2s;
        }

        .numpad button:hover {
            background: #5568d3;
        }

        .numpad button.erase {
            background: #ff6b6b;
        }

        .numpad button.erase:hover {
            background: #ee5a5a;
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }

        .action-buttons button {
            padding: 10px 20px;
            font-size: 14px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .restart-btn {
            background: #667eea;
            color: white;
        }

        .restart-btn:hover {
            background: #5568d3;
        }

        .hint-btn {
            background: #4CAF50;
            color: white;
        }

        .hint-btn:hover {
            background: #45a049;
        }

        .check-btn {
            background: #FF9800;
            color: white;
        }

        .check-btn:hover {
            background: #e68900;
        }

        .leaderboard-btn {
            background: #9C27B0;
            color: white;
        }

        .leaderboard-btn:hover {
            background: #7B1FA2;
        }

        /* ç§¯åˆ†æ¦œæ ·å¼ */
        .leaderboard-panel {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 30px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            width: 500px;
            max-width: 90%;
            z-index: 1000;
            display: none;
        }

        .leaderboard-container {
            margin-bottom: 20px;
            max-height: 400px;
            overflow-y: auto;
        }

        .leaderboard-table {
            width: 100%;
            border-collapse: collapse;
        }

        .leaderboard-table th, .leaderboard-table td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }

        .leaderboard-table th {
            background: #f8f9fa;
            font-weight: bold;
            color: #333;
        }

        .leaderboard-table tr:hover {
            background: #f8f9fa;
        }

        .leaderboard-table .rank-1 {
            font-weight: bold;
            color: #FFD700;
        }

        .leaderboard-table .rank-2 {
            font-weight: bold;
            color: #C0C0C0;
        }

        .leaderboard-table .rank-3 {
            font-weight: bold;
            color: #CD7F32;
        }

        .leaderboard-controls {
            text-align: center;
        }

        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            text-align: center;
            display: none;
            z-index: 1000;
        }

        .game-over h2 {
            color: #4CAF50;
            margin-bottom: 20px;
        }

        .game-over button {
            background: #667eea;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin-top: 15px;
            transition: background 0.3s;
        }

        .game-over button:hover {
            background: #5568d3;
        }

        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: none;
            z-index: 999;
        }

        .stats {
            text-align: center;
            margin-top: 15px;
            color: #666;
        }

        .stats span {
            margin: 0 15px;
        }

        @media (max-width: 600px) {
            .sudoku-grid {
                width: 320px;
                height: 320px;
            }

            .sudoku-cell {
                width: 35.5px;
                height: 35.5px;
                font-size: 18px;
            }

            .numpad {
                max-width: 250px;
            }
        }
    </style>
</head>
<body>
    <button class="close-btn" onclick="goBackHome()" title="è¿”å›ä¸»é¡µ">Ã—</button>

    <div class="game-container game-container-bottom-nails">
        <h1>ğŸ´â€â˜ ï¸ æ•°ç‹¬å†’é™©</h1>

        <div class="game-info">
            <div class="difficulty-selector">
                <label>éš¾åº¦:</label>
                <select id="difficulty" onchange="changeDifficulty()">
                    <option value="easy">ç®€å•</option>
                    <option value="medium">ä¸­ç­‰</option>
                    <option value="hard">å›°éš¾</option>
                </select>
            </div>
            <div class="stats">
                <span>é”™è¯¯: <span id="errors">0</span></span>
                <span>æ—¶é—´: <span id="timer">00:00</span></span>
            </div>
        </div>

        <div class="sudoku-container">
            <div class="sudoku-grid" id="sudokuGrid"></div>

            <div class="numpad">
                <button onclick="inputNumber(1)">1</button>
                <button onclick="inputNumber(2)">2</button>
                <button onclick="inputNumber(3)">3</button>
                <button onclick="inputNumber(4)">4</button>
                <button onclick="inputNumber(5)">5</button>
                <button onclick="inputNumber(6)">6</button>
                <button onclick="inputNumber(7)">7</button>
                <button onclick="inputNumber(8)">8</button>
                <button onclick="inputNumber(9)">9</button>
                <button class="erase" onclick="inputNumber(0)">âœ•</button>
            </div>
        </div>

        <div class="action-buttons">
            <button class="restart-btn" onclick="restartGame()">é‡æ–°å¼€å§‹</button>
            <button class="hint-btn" onclick="showHint()">æç¤º</button>
            <button class="check-btn" onclick="checkSolution()">æ£€æŸ¥</button>
            <button class="leaderboard-btn" onclick="showLeaderboard()">æŸ¥çœ‹æ’è¡Œæ¦œ</button>
        </div>

        <div class="controls">
            <p>ç‚¹å‡»æ ¼å­é€‰æ‹©ï¼Œç„¶åç‚¹å‡»æ•°å­—é”®å¡«å…¥</p>
        </div>
    </div>

    <div class="game-over-overlay" id="gameOverOverlay"></div>
    <div class="game-over" id="gameOver">
        <h2>ğŸ‰ æ­å–œå®Œæˆï¼</h2>
        <p>ç”¨æ—¶: <span id="finalTime">00:00</span></p>
        <p>é”™è¯¯: <span id="finalErrors">0</span> æ¬¡</p>
        <p>éš¾åº¦: <span id="finalDifficulty">ç®€å•</span></p>

        <div id="nameInputSection">
            <input type="text" id="playerName" placeholder="è¾“å…¥ä½ çš„åå­—" maxlength="10"
                   style="padding: 10px; font-size: 16px; border: 2px solid var(--onepiece-gold); border-radius: 5px; margin: 10px 0; width: 200px;">
            <br>
            <button onclick="saveScore()">ä¿å­˜æˆç»©</button>
            <button onclick="hideNameInput()">è·³è¿‡</button>
        </div>

        <div id="leaderboardSection" style="display: none; margin-top: 15px; text-align: left;">
            <h3 style="color: var(--onepiece-ocean-deep); margin-bottom: 10px;">ğŸ† æ’è¡Œæ¦œ</h3>
            <div id="leaderboardList" style="max-height: 200px; overflow-y: auto; background: var(--onepiece-cream); padding: 10px; border-radius: 5px; border: 2px solid var(--onepiece-gold);">
                <!-- æ’è¡Œæ¦œå†…å®¹ -->
            </div>
        </div>

        <button onclick="restartGame()" style="margin-top: 15px;">å†æ¥ä¸€å±€</button>
        <button onclick="goBackHome()" style="margin-top: 10px; background: linear-gradient(145deg, var(--onepiece-ocean-mid), var(--onepiece-ocean-deep));">è¿”å›ä¸»é¡µ</button>
    </div>

    <!-- ç§¯åˆ†æ¦œé¢æ¿ -->
    <div class="leaderboard-panel" id="leaderboardPanel">
        <h3 style="text-align: center; color: #333; margin-bottom: 20px;">ğŸ† å…¨çƒç§¯åˆ†æ¦œ</h3>
        <div class="leaderboard-container">
            <table class="leaderboard-table">
                <thead>
                    <tr>
                        <th>æ’å</th>
                        <th>ç©å®¶</th>
                        <th>ç”¨æ—¶</th>
                        <th>é”™è¯¯æ•°</th>
                        <th>éš¾åº¦</th>
                    </tr>
                </thead>
                <tbody id="leaderboardBody">
                    <!-- åŠ¨æ€å¡«å…… -->
                </tbody>
            </table>
        </div>
        <div class="leaderboard-controls">
            <button class="btn" onclick="hideLeaderboard()" style="padding: 10px 20px; border: none; border-radius: 8px; cursor: pointer; background: #667eea; color: white; transition: background 0.3s; font-size: 14px;">å…³é—­</button>
        </div>
    </div>

    <script>
        const GRID_SIZE = 9;
        const BOX_SIZE = 3;
        let grid = [];
        let solution = [];
        let selectedCell = null;
        let moveHistory = [];
        let errors = 0;
        let timer = 0;
        let timerInterval = null;
        let isGameOver = false;
        let difficulty = 'easy';

        // æ’è¡Œæ¦œAPIé…ç½®ï¼ˆä½¿ç”¨ç›¸å¯¹è·¯å¾„ï¼Œè‡ªåŠ¨é€‚é…æœ¬åœ°/å¤–ç½‘è®¿é—®ï¼‰
        // ç°åœ¨ä½¿ç”¨8080ç«¯å£ï¼ˆä¸æ¸¸æˆç½‘ç«™åˆå¹¶ï¼‰
        const LEADERBOARD_API = window.location.origin + '/api/leaderboard/sudoku';
        let leaderboardData = [];
        let leaderboardCache = null;

        // ä»APIè·å–æ’è¡Œæ¦œæ•°æ®
        async function fetchLeaderboard() {
            try {
                const response = await fetch(LEADERBOARD_API, { cache: 'no-store' });
                const result = await response.json();
                if (result.success) {
                    leaderboardData = result.leaderboard;
                    leaderboardCache = leaderboardData;
                    return leaderboardData;
                }
            } catch (error) {
                console.error('è·å–æ’è¡Œæ¦œå¤±è´¥:', error);
                // å¦‚æœAPIå¤±è´¥ï¼Œä½¿ç”¨ç¼“å­˜æ•°æ®
                if (leaderboardCache) {
                    console.log('ä½¿ç”¨ç¼“å­˜æ•°æ®');
                    leaderboardData = leaderboardCache;
                }
            }
            return leaderboardData || [];
        }

        // ä¿å­˜åˆ†æ•°åˆ°API
        async function saveScoreToAPI(scoreData) {
            try {
                console.log('æ­£åœ¨ä¿å­˜æ•°ç‹¬åˆ†æ•°:', scoreData);
                const response = await fetch(LEADERBOARD_API, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(scoreData)
                });

                if (!response.ok) {
                    console.error('APIå“åº”é”™è¯¯:', response.status, response.statusText);
                    return false;
                }

                const result = await response.json();
                console.log('APIè¿”å›:', result);

                if (result.success) {
                    leaderboardData = result.leaderboard;
                    leaderboardCache = leaderboardData;
                    return true;
                } else {
                    console.error('APIè¿”å›é”™è¯¯:', result.error);
                    return false;
                }
            } catch (error) {
                console.error('ä¿å­˜åˆ†æ•°å¤±è´¥:', error);
                return false;
            }
        }

        const sudokuGrid = document.getElementById('sudokuGrid');

function initGrid() {
            sudokuGrid.innerHTML = '';
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'sudoku-cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    cell.addEventListener('click', () => selectCell(i, j));
                    sudokuGrid.appendChild(cell);
                }
            }
        }

        function generateSolution() {
  // æ ‡å‡†æ•°ç‹¬è§£æ¨¡æ¿
  const base = [
    [5,3,4,6,7,8,9,1,2],
    [6,7,2,1,9,5,3,4,8],
    [1,9,8,3,4,2,5,6,7],
    [8,5,9,7,6,1,4,2,3],
    [4,2,6,8,5,3,7,9,1],
    [7,1,3,9,2,4,8,5,6],
    [9,6,1,5,3,7,2,8,4],
    [2,8,7,4,1,9,6,3,5],
    [3,4,5,2,8,6,1,7,9]
  ];
  let grid = base.map(row => [...row]);
  const rand = (n) => Math.floor(Math.random() * n);
  const mapping = {};
  const nums = [1, 2, 3, 4, 5, 6, 7, 8, 9].sort(() => Math.random() - 0.5);

  // æ•°å­—æ˜ å°„
  for(let i = 0; i < 9; i++) {
    mapping[i + 1] = nums[i];
  }

  // åº”ç”¨æ•°å­—æ˜ å°„
  for(let i = 0; i < 9; i++) {
    for(let j = 0; j < 9; j++) {
      grid[i][j] = mapping[grid[i][j]];
    }
  }

  // éšæœºäº¤æ¢è¡Œï¼ˆåœ¨æ¯ä¸ª3x3å®«å†…ï¼‰
  for(let box = 0; box < 3; box++) {
    const r1 = box * 3 + rand(3);
    const r2 = box * 3 + rand(3);
    [grid[r1], grid[r2]] = [grid[r2], grid[r1]];
  }

  // éšæœºäº¤æ¢åˆ—ï¼ˆåœ¨æ¯ä¸ª3x3å®«å†…ï¼‰
  for(let box = 0; box < 3; box++) {
    const c1 = box * 3 + rand(3);
    const c2 = box * 3 + rand(3);
    for(let r = 0; r < 9; r++) {
      [grid[r][c1], grid[r][c2]] = [grid[r][c2], grid[r][c1]];
    }
  }

  // éšæœºäº¤æ¢3x3å®«
  const blockOrder = [[0, 1, 2], [1, 0, 2], [2, 1, 0]][rand(3)];
  const newGrid = [];
  for(let b of blockOrder) {
    for(let i = 0; i < 3; i++) {
      newGrid.push(grid[b * 3 + i]);
    }
  }

  solution = newGrid;
}

        function isValidPlacement(grid, row, col, num) {
            // æ£€æŸ¥è¡Œ
            for (let j = 0; j < GRID_SIZE; j++) {
                if (grid[row][j] === num) return false;
            }

            // æ£€æŸ¥åˆ—
            for (let i = 0; i < GRID_SIZE; i++) {
                if (grid[i][col] === num) return false;
            }

            // æ£€æŸ¥3x3å®«
            const boxRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
            const boxCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
            for (let i = boxRow; i < boxRow + BOX_SIZE; i++) {
                for (let j = boxCol; j < boxCol + BOX_SIZE; j++) {
                    if (grid[i][j] === num) return false;
                }
            }

            return true;
        }

        function generatePuzzle() {
            generateSolution();

            const puzzle = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                puzzle[i] = [];
                for (let j = 0; j < GRID_SIZE; j++) {
                    puzzle[i][j] = solution[i][j];
                }
            }

            let cellsToRemove;
            switch (difficulty) {
                case 'easy':
                    cellsToRemove = 30;
                    break;
                case 'medium':
                    cellsToRemove = 45;
                    break;
                case 'hard':
                    cellsToRemove = 55;
                    break;
                default:
                    cellsToRemove = 30;
            }

            let removed = 0;
            const positions = [];
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    positions.push({row: i, col: j});
                }
            }

            // éšæœºæ‰“ä¹±ä½ç½®
            for (let i = positions.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [positions[i], positions[j]] = [positions[j], positions[i]];
            }

            for (let pos of positions) {
                if (removed >= cellsToRemove) break;

                const backup = puzzle[pos.row][pos.col];
                puzzle[pos.row][pos.col] = 0;

                // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å”¯ä¸€è§£
                const unique = countUniqueSolutions(puzzle, 2);
                if (unique !== 1) {
                    puzzle[pos.row][pos.col] = backup;
                } else {
                    removed++;
                }
            }

            return puzzle;
        }

        function countUniqueSolutions(currentGrid, limit=2) {
  if(!currentGrid) return 0;
  let count=0;
  function solve(grid){
    if(count>=limit) return;
    let er=-1, ec=-1;
    for(let i=0;i<GRID_SIZE;i++){
      for(let j=0;j<GRID_SIZE;j++){
        if(grid[i][j]===0){er=i;ec=j;break;}
      }
      if(er!==-1) break;
    }
    if(er===-1){count++;return;}
    for(let num=1;num<=GRID_SIZE&&count<limit;num++){
      if(isValidPlacement(grid,er,ec,num)){
        grid[er][ec]=num;
        solve(grid);
        grid[er][ec]=0;
      }
    }
  }
  solve(currentGrid.map(r=>[...r]));
  return count;
}

function loadPuzzle() {
            grid = generatePuzzle();

            const cells = sudokuGrid.querySelectorAll('.sudoku-cell');
            cells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const value = grid[row][col];

                cell.textContent = value === 0 ? '' : value;
                cell.classList.remove('fixed', 'error', 'selected', 'highlight');

                if (value !== 0) {
                    cell.classList.add('fixed');
                }
            });
        }

        function selectCell(row, col) {
            if (isGameOver) return;

            // æ¸…é™¤ä¹‹å‰çš„é€‰ä¸­
            if (selectedCell) {
                const prevCell = sudokuGrid.querySelector(
                    `.sudoku-cell[data-row="${selectedCell.row}"][data-col="${selectedCell.col}"]`
                );
                if (prevCell) prevCell.classList.remove('selected', 'highlight');
            }

            // æ·»åŠ æ–°çš„é€‰ä¸­
            selectedCell = {row, col};
            const cell = sudokuGrid.querySelector(
                `.sudoku-cell[data-row="${row}"][data-col="${col}"]`
            );
            if (cell) cell.classList.add('selected');

            // é«˜äº®ç›¸å…³æ ¼å­
            highlightRelatedCells(row, col);
        }

        function highlightRelatedCells(row, col) {
            const cells = sudokuGrid.querySelectorAll('.sudoku-cell');

            cells.forEach(cell => {
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);

                // é«˜äº®åŒè¡Œã€åŒåˆ—ã€åŒå®«
                const sameRow = r === row;
                const sameCol = c === col;
                const sameBox =
                    Math.floor(r / BOX_SIZE) === Math.floor(row / BOX_SIZE) &&
                    Math.floor(c / BOX_SIZE) === Math.floor(col / BOX_SIZE);

                if (sameRow || sameCol || sameBox) {
                    cell.classList.add('highlight');
                } else {
                    cell.classList.remove('highlight');
                }
            });
        }

        function inputNumber(num) {
            if (!selectedCell || isGameOver) return;

            const {row, col} = selectedCell;
            const cell = sudokuGrid.querySelector(
                `.sudoku-cell[data-row="${row}"][data-col="${col}"]`
            );

            if (!cell || cell.classList.contains('fixed')) return;
            const oldValue = grid[row][col];

            if (num === 0) {
                // æ¸…é™¤
                grid[row][col] = 0;
                cell.textContent = '';
                cell.classList.remove('error');
                moveHistory.push({row, col, oldValue, newValue: num});
                return;
            }

            // é¦–å…ˆæ£€æŸ¥æ˜¯å¦è¿åæ•°ç‹¬è§„åˆ™ï¼ˆè¡Œã€åˆ—ã€å®«æ ¼é‡å¤ï¼‰
            const checkResult = checkCell(row, col, num);
            if (!checkResult.valid) {
                // è¿åæ•°ç‹¬è§„åˆ™
                errors++;
                document.getElementById('errors').textContent = errors;
                cell.classList.add('error');
                grid[row][col] = num;
                cell.textContent = num;
                moveHistory.push({row, col, oldValue, newValue: num});
                return;
            }

            // æ£€æŸ¥æ˜¯å¦æ­£ç¡®
            if (num === solution[row][col]) {
                grid[row][col] = num;
                cell.textContent = num;
                cell.classList.remove('error');
                moveHistory.push({row, col, oldValue, newValue: num});

                // æ£€æŸ¥æ˜¯å¦å®Œæˆ
                if (checkWin()) {
                    gameOver();
                }
            } else {
                // ç­”æ¡ˆé”™è¯¯
                errors++;
                document.getElementById('errors').textContent = errors;
                cell.classList.add('error');
                grid[row][col] = num;
                cell.textContent = num;
                moveHistory.push({row, col, oldValue, newValue: num});
            }
        }

        function showHint() {
            if (!selectedCell || isGameOver) return;

            const {row, col} = selectedCell;
            const cell = sudokuGrid.querySelector(
                `.sudoku-cell[data-row="${row}"][data-col="${col}"]`
            );

            if (!cell || cell.classList.contains('fixed')) return;
  const hintOldValue = grid[row][col];
  moveHistory.push({row, col, oldValue: hintOldValue, newValue: solution[row][col], isHint: true});

            // å¡«å…¥æ­£ç¡®ç­”æ¡ˆ
            grid[row][col] = solution[row][col];
            cell.textContent = solution[row][col];
            cell.classList.remove('error');

            if (checkWin()) {
                gameOver();
            }
        }

        function undo() {
  if (moveHistory.length === 0 || isGameOver) return;
  const lastMove = moveHistory.pop();
  const {row, col, oldValue} = lastMove;
  grid[row][col] = oldValue;
  const cell = sudokuGrid.querySelector(
    `.sudoku-cell[data-row="${row}"][data-col="${col}"]`
  );
  if (cell) {
    cell.textContent = oldValue === 0 ? '' : oldValue;
    cell.classList.remove('error');
  }
  selectCell(row, col);
}

        // æ£€æŸ¥æŒ‡å®šæ ¼å­å¡«å…¥çš„æ•°å­—æ˜¯å¦è¿åæ•°ç‹¬è§„åˆ™
        function checkCell(row, col, num) {
            // æ£€æŸ¥è¡Œ
            for (let j = 0; j < GRID_SIZE; j++) {
                if (j !== col && grid[row][j] === num) {
                    return { valid: false, message: `ç¬¬ ${row + 1} è¡Œå·²æœ‰æ•°å­— ${num}` };
                }
            }

            // æ£€æŸ¥åˆ—
            for (let i = 0; i < GRID_SIZE; i++) {
                if (i !== row && grid[i][col] === num) {
                    return { valid: false, message: `ç¬¬ ${col + 1} åˆ—å·²æœ‰æ•°å­— ${num}` };
                }
            }

            // æ£€æŸ¥3x3å®«æ ¼
            const boxRow = Math.floor(row / BOX_SIZE) * BOX_SIZE;
            const boxCol = Math.floor(col / BOX_SIZE) * BOX_SIZE;
            for (let i = boxRow; i < boxRow + BOX_SIZE; i++) {
                for (let j = boxCol; j < boxCol + BOX_SIZE; j++) {
                    if ((i !== row || j !== col) && grid[i][j] === num) {
                        return { valid: false, message: `æ‰€åœ¨å®«æ ¼å·²æœ‰æ•°å­— ${num}` };
                    }
                }
            }

            return { valid: true };
        }

        function checkSolution() {
            if (isGameOver) return;

            const cells = sudokuGrid.querySelectorAll('.sudoku-cell');
            let hasErrors = false;

            cells.forEach(cell => {
                const row = parseInt(cell.dataset.row);
                const col = parseInt(cell.dataset.col);
                const value = grid[row][col];

                // æ¸…é™¤ä¹‹å‰çš„é”™è¯¯æ ‡è®°
                cell.classList.remove('error');

                if (value !== 0) {
                    // æ£€æŸ¥æ˜¯å¦è¿åæ•°ç‹¬è§„åˆ™ï¼ˆè¡Œã€åˆ—ã€å®«æ ¼é‡å¤ï¼‰
                    const checkResult = checkCell(row, col, value);
                    if (!checkResult.valid) {
                        cell.classList.add('error');
                        hasErrors = true;
                    } else if (value !== solution[row][col]) {
                        // ä¸è¿åè§„åˆ™ä½†ä¸ç­”æ¡ˆä¸ç¬¦
                        cell.classList.add('error');
                        hasErrors = true;
                    }
                }
            });

            if (!hasErrors && !checkWin()) {
                alert('ç›®å‰æ²¡æœ‰é”™è¯¯ï¼ç»§ç»­åŠ æ²¹ï¼');
            }
        }

        function checkWin() {
            for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                    if (grid[i][j] !== solution[i][j]) return false;
                }
            }
            return true;
        }

        function startTimer() {
            timer = 0;
            document.getElementById('timer').textContent = '00:00';

            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                timer++;
                const minutes = Math.floor(timer / 60).toString().padStart(2, '0');
                const seconds = (timer % 60).toString().padStart(2, '0');
                document.getElementById('timer').textContent = `${minutes}:${seconds}`;
            }, 1000);
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function gameOver() {
            isGameOver = true;
            stopTimer();

            const minutes = Math.floor(timer / 60).toString().padStart(2, '0');
            const seconds = (timer % 60).toString().padStart(2, '0');
            document.getElementById('finalTime').textContent = `${minutes}:${seconds}`;

            document.getElementById('gameOverOverlay').style.display = 'block';
            document.getElementById('gameOver').style.display = 'block';

            // æ˜¾ç¤ºåå­—è¾“å…¥æ¡†
            document.getElementById('nameInputSection').style.display = 'block';
            document.getElementById('leaderboardSection').style.display = 'none';
            document.getElementById('playerName').value = '';
            document.getElementById('playerName').focus();
        }

        function changeDifficulty() {
            difficulty = document.getElementById('difficulty').value;
            restartGame();
        }

        function restartGame() {
            isGameOver = false;
            errors = 0;
            selectedCell = null;
            stopTimer();
            startTimer();

            document.getElementById('errors').textContent = '0';
            document.getElementById('timer').textContent = '00:00';
            document.getElementById('gameOverOverlay').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';

            loadPuzzle();
        }

        // é”®ç›˜æ§åˆ¶
        document.addEventListener('keydown', (e) => {
            if (!selectedCell || isGameOver) return;

            const {row, col} = selectedCell;

            switch(e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    if (row > 0) selectCell(row - 1, col);
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    if (row < GRID_SIZE - 1) selectCell(row + 1, col);
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    if (col > 0) selectCell(row, col - 1);
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    if (col < GRID_SIZE - 1) selectCell(row, col + 1);
                    break;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    inputNumber(parseInt(e.key));
                    break;
                case 'Backspace':
                case 'Delete':
                    inputNumber(0);
                    break;
            }
        });

        // åˆå§‹åŒ–æ¸¸æˆ
        initGrid();
        restartGame();

        // è¿”å›ä¸»é¡µ
        function goBackHome() {
            window.location.href = '../../index.html';
        }

        // ä¿å­˜æˆç»©
        async function saveScore() {
            const btn = event.target;
            const playerName = document.getElementById('playerName').value.trim() || 'åŒ¿å';
            const scoreData = {
                name: playerName,
                time: timer,
                errors: errors,
                difficulty: difficulty
            };

            // ç¦ç”¨æŒ‰é’®ï¼Œé˜²æ­¢é‡å¤ç‚¹å‡»
            btn.disabled = true;
            btn.textContent = 'ä¿å­˜ä¸­...';

            // ä¿å­˜åˆ°API
            const success = await saveScoreToAPI(scoreData);

            if (success) {
                btn.textContent = 'âœ… å·²ä¿å­˜';
                setTimeout(() => {
                    hideNameInput();
                    displayLeaderboard();
                    btn.disabled = false;
                    btn.textContent = 'ä¿å­˜æˆç»©';
                }, 1000);
            } else {
                btn.disabled = false;
                btn.textContent = 'ä¿å­˜æˆç»©';
                alert('ä¿å­˜å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
            }
        }

        // éšè—åå­—è¾“å…¥
        function hideNameInput() {
            document.getElementById('nameInputSection').style.display = 'none';
            displayLeaderboard();
        }

        // æ˜¾ç¤ºæ’è¡Œæ¦œ
        // æ˜¾ç¤ºæ’è¡Œæ¦œï¼ˆé¢æ¿æ¨¡å¼ï¼‰
        async function showLeaderboard() {
            const panel = document.getElementById('leaderboardPanel');
            const tbody = document.getElementById('leaderboardBody');

            // å…ˆæ˜¾ç¤ºé¢æ¿å’ŒåŠ è½½æç¤º
            tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 30px;">â³ åŠ è½½ä¸­...</td></tr>';
            panel.style.display = 'block';

            // ä»APIè·å–æœ€æ–°æ•°æ®
            await fetchLeaderboard();

            // æ’åºï¼šç”¨æ—¶è¶Šå°‘è¶Šå¥½
            leaderboardData.sort((a, b) => a.time - b.time);

            // å¡«å……è¡¨æ ¼
            tbody.innerHTML = '';

            if (leaderboardData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align: center; padding: 20px;">æš‚æ— è®°å½•</td></tr>';
                return;
            }

            leaderboardData.forEach((score, index) => {
                const row = document.createElement('tr');
                row.className = index < 3 ? `rank-${index + 1}` : '';

                const minutes = Math.floor(score.time / 60).toString().padStart(2, '0');
                const seconds = (score.time % 60).toString().padStart(2, '0');

                const diffText = {
                    'easy': 'ç®€å•',
                    'medium': 'ä¸­ç­‰',
                    'hard': 'å›°éš¾'
                }[score.difficulty];

                row.innerHTML = `
                    <td>${index + 1}</td>
                    <td>${score.name || 'åŒ¿åç©å®¶'}</td>
                    <td>${minutes}:${seconds}</td>
                    <td>${score.errors}</td>
                    <td>${diffText}</td>
                `;

                tbody.appendChild(row);
            });
        }

        // éšè—æ’è¡Œæ¦œ
        function hideLeaderboard() {
            const panel = document.getElementById('leaderboardPanel');
            panel.style.display = 'none';
        }

        async function displayLeaderboard() {
            const leaderboardList = document.getElementById('leaderboardList');
            const leaderboardSection = document.getElementById('leaderboardSection');

            // å…ˆæ˜¾ç¤ºåŠ è½½æç¤º
            leaderboardSection.style.display = 'block';
            leaderboardList.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">â³ åŠ è½½ä¸­...</p>';

            // ä»APIè·å–æœ€æ–°æ•°æ®
            await fetchLeaderboard();

            if (leaderboardData.length === 0) {
                leaderboardList.innerHTML = '<p style="text-align: center; color: #666;">æš‚æ— è®°å½•ï¼Œå¿«æ¥åˆ›é€ ç¬¬ä¸€ä¸ªè®°å½•å§ï¼</p>';
            } else {
                let html = '';
                leaderboardData.forEach((score, index) => {
                    const minutes = Math.floor(score.time / 60).toString().padStart(2, '0');
                    const seconds = (score.time % 60).toString().padStart(2, '0');
                    const medals = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'];
                    const medal = index < 3 ? medals[index] : `${index + 1}.`;

                    const diffText = {
                        'easy': 'ç®€å•',
                        'medium': 'ä¸­ç­‰',
                        'hard': 'å›°éš¾'
                    }[score.difficulty];

                    html += `
                        <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px 5px; border-bottom: 1px solid #ddd;">
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <span style="font-size: 18px;">${medal}</span>
                                <div>
                                    <div style="font-weight: bold; color: var(--onepiece-black);">${score.name}</div>
                                    <div style="font-size: 12px; color: var(--onepiece-wood-dark);">${diffText}</div>
                                </div>
                            </div>
                            <div style="text-align: right;">
                                <div style="font-weight: bold; color: var(--onepiece-ocean-deep);">${minutes}:${seconds}</div>
                                <div style="font-size: 12px; color: #cc0000;">é”™è¯¯: ${score.errors}</div>
                            </div>
                        </div>
                    `;
                });

                leaderboardList.innerHTML = html;
            }

            document.getElementById('finalErrors').textContent = errors;

            const diffText = {
                'easy': 'ç®€å•',
                'medium': 'ä¸­ç­‰',
                'hard': 'å›°éš¾'
            }[difficulty];
            document.getElementById('finalDifficulty').textContent = diffText;
        }
    </script>
</body>
</html>
