<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>èˆªæµ·ç‹å¡”é˜² - å®ˆæŠ¤å®è—</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: none;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0a1628 0%, #1a3a5c 50%, #0d2137 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
            color: #fff;
        }
        
        #gameContainer {
            position: relative;
            width: 100%;
            max-width: 900px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }
        
        #gameCanvas {
            background: linear-gradient(180deg, #0d2137 0%, #1a3a5c 100%);
            border: 3px solid #d4a84b;
            border-radius: 8px;
            box-shadow: 0 0 30px rgba(212, 168, 75, 0.3), inset 0 0 60px rgba(0,0,0,0.5);
            cursor: crosshair;
        }
        
        .ui-header {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 10;
            background: rgba(10, 22, 40, 0.9);
            padding: 10px 25px;
            border-radius: 25px;
            border: 2px solid #d4a84b;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .stat-box {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 16px;
            font-weight: bold;
        }
        
        .stat-label {
            color: #d4a84b;
            text-transform: uppercase;
            letter-spacing: 1px;
            font-size: 11px;
        }
        
        .stat-value {
            color: #fff;
            text-shadow: 0 0 10px rgba(255,255,255,0.5);
        }
        
        .hearts {
            display: flex;
            gap: 3px;
        }
        
        .heart {
            color: #e74c3c;
            font-size: 16px;
            text-shadow: 0 0 10px rgba(231, 76, 60, 0.8);
        }
        
        .heart.lost {
            color: #444;
            text-shadow: none;
        }
        
        /* Tower Selection Panel */
        .tower-panel {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 10;
            background: rgba(10, 22, 40, 0.95);
            padding: 10px 15px;
            border-radius: 15px;
            border: 2px solid #d4a84b;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        
        .tower-btn {
            width: 60px;
            height: 60px;
            border: 2px solid #d4a84b;
            background: rgba(212, 168, 75, 0.1);
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .tower-btn:hover {
            background: rgba(212, 168, 75, 0.3);
            transform: scale(1.1);
        }
        
        .tower-btn.selected {
            background: rgba(212, 168, 75, 0.5);
            box-shadow: 0 0 15px rgba(212, 168, 75, 0.6);
        }
        
        .tower-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        
        .tower-icon {
            font-size: 24px;
            margin-bottom: 2px;
        }
        
        .tower-cost {
            font-size: 10px;
            color: #ffd700;
        }
        
        .tower-name {
            font-size: 9px;
            color: #87ceeb;
        }
        
        /* Menu Styles */
        .menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 22, 40, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            border-radius: 8px;
        }
        
        .menu-overlay.hidden {
            display: none;
        }
        
        .game-title {
            font-family: 'Cinzel', serif;
            font-size: clamp(32px, 7vw, 48px);
            color: #d4a84b;
            text-shadow: 
                0 0 10px rgba(212, 168, 75, 0.8),
                0 0 20px rgba(212, 168, 75, 0.5),
                3px 3px 0px #8b0000;
            margin-bottom: 10px;
            letter-spacing: 4px;
            text-align: center;
        }
        
        .game-subtitle {
            color: #87ceeb;
            font-size: 18px;
            margin-bottom: 30px;
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 0 10px rgba(135, 206, 235, 0.5);
        }
        
        .difficulty-section {
            margin-bottom: 25px;
            text-align: center;
        }
        
        .difficulty-label {
            color: #d4a84b;
            font-size: 16px;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .difficulty-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .diff-btn {
            padding: 10px 25px;
            font-size: 14px;
            font-weight: bold;
            border: 2px solid #d4a84b;
            background: rgba(212, 168, 75, 0.1);
            color: #d4a84b;
            cursor: pointer;
            border-radius: 25px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .diff-btn:hover, .diff-btn.active {
            background: #d4a84b;
            color: #0a1628;
            box-shadow: 0 0 20px rgba(212, 168, 75, 0.6);
            transform: scale(1.05);
        }
        
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
        }
        
        .menu-btn {
            padding: 12px 40px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            cursor: pointer;
            border-radius: 30px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            min-width: 200px;
        }
        
        .start-btn {
            background: linear-gradient(135deg, #d4a84b 0%, #f0d78c 50%, #d4a84b 100%);
            color: #0a1628;
            box-shadow: 0 4px 20px rgba(212, 168, 75, 0.5);
        }
        
        .start-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(212, 168, 75, 0.7);
        }
        
        .home-btn {
            background: linear-gradient(135deg, #3498db 0%, #5dade2 50%, #3498db 100%);
            color: #fff;
            box-shadow: 0 4px 20px rgba(52, 152, 219, 0.5);
        }
        
        .home-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(52, 152, 219, 0.7);
        }
        
        .game-over-title {
            font-family: 'Cinzel', serif;
            font-size: clamp(28px, 5vw, 42px);
            color: #e74c3c;
            text-shadow: 0 0 20px rgba(231, 76, 60, 0.8);
            margin-bottom: 15px;
        }
        
        .victory-title {
            color: #2ecc71;
            text-shadow: 0 0 20px rgba(46, 204, 113, 0.8);
        }
        
        .final-stats {
            font-size: 18px;
            color: #d4a84b;
            margin-bottom: 20px;
            text-align: center;
            line-height: 1.8;
        }
        
        .pause-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            color: #d4a84b;
            text-shadow: 0 0 20px rgba(212, 168, 75, 0.8);
            display: none;
            z-index: 50;
            font-family: 'Cinzel', serif;
            letter-spacing: 4px;
        }
        
        .controls-hint {
            margin-top: 25px;
            color: #87ceeb;
            font-size: 13px;
            text-align: center;
            line-height: 1.6;
            opacity: 0.8;
        }
        
        .controls-hint span {
            color: #d4a84b;
        }
        
        .instructions {
            max-width: 500px;
            background: rgba(0,0,0,0.3);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid #d4a84b;
        }
        
        .instructions h3 {
            color: #d4a84b;
            margin-bottom: 10px;
            font-size: 16px;
        }
        
        .instructions ul {
            list-style: none;
            padding: 0;
        }
        
        .instructions li {
            color: #87ceeb;
            font-size: 12px;
            margin-bottom: 5px;
            padding-left: 15px;
            position: relative;
        }
        
        .instructions li::before {
            content: 'âš”ï¸';
            position: absolute;
            left: 0;
            font-size: 10px;
        }
        
        .pause-menu-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 22, 40, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 200;
            border-radius: 8px;
        }
        
        .pause-menu-overlay.show {
            display: flex;
        }
        
        .pause-menu-title {
            font-family: 'Cinzel', serif;
            font-size: clamp(28px, 5vw, 42px);
            color: #d4a84b;
            text-shadow: 0 0 20px rgba(212, 168, 75, 0.8);
            margin-bottom: 30px;
        }
        
        .pause-menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center;
        }
        
        .pause-menu-btn {
            padding: 12px 40px;
            font-size: 16px;
            font-weight: bold;
            border: none;
            cursor: pointer;
            border-radius: 30px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 2px;
            min-width: 200px;
        }
        
        .resume-btn {
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 50%, #2ecc71 100%);
            color: #fff;
            box-shadow: 0 4px 20px rgba(46, 204, 113, 0.5);
        }
        
        .resume-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(46, 204, 113, 0.7);
        }
        
        .back-menu-btn {
            background: linear-gradient(135deg, #3498db 0%, #5dade2 50%, #3498db 100%);
            color: #fff;
            box-shadow: 0 4px 20px rgba(52, 152, 219, 0.5);
        }
        
        .back-menu-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(52, 152, 219, 0.7);
        }
        
        .game-pause-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 45px;
            height: 45px;
            background: rgba(212, 168, 75, 0.9);
            border: 2px solid #d4a84b;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            font-weight: bold;
            color: #0a1628;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 60;
            transition: all 0.3s;
        }
        
        .game-pause-btn:hover {
            background: #d4a84b;
            transform: scale(1.1);
        }
        
        .back-home-btn {
            position: absolute;
            top: 15px;
            right: 70px;
            width: 45px;
            height: 45px;
            background: rgba(231, 76, 60, 0.9);
            border: 2px solid #e74c3c;
            border-radius: 50%;
            cursor: pointer;
            font-size: 24px;
            font-weight: bold;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 60;
            transition: all 0.3s;
            text-decoration: none;
        }
        
        .back-home-btn:hover {
            background: #c0392b;
            transform: scale(1.1);
        }
        
        /* Tower Info Popup */
        .tower-info-popup {
            position: absolute;
            background: rgba(10, 22, 40, 0.98);
            border: 2px solid #d4a84b;
            border-radius: 10px;
            padding: 15px;
            z-index: 70;
            display: none;
            min-width: 180px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }
        
        .tower-info-popup.show {
            display: block;
        }
        
        .tower-info-title {
            color: #d4a84b;
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .tower-info-stat {
            color: #87ceeb;
            font-size: 12px;
            margin-bottom: 4px;
        }
        
        .tower-info-stat span {
            color: #fff;
        }
        
        .upgrade-btn {
            width: 100%;
            padding: 8px;
            margin-top: 10px;
            background: linear-gradient(135deg, #2ecc71 0%, #27ae60 100%);
            border: none;
            border-radius: 5px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }
        
        .upgrade-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(46, 204, 113, 0.5);
        }
        
        .upgrade-btn.disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }
        
        .sell-btn {
            width: 100%;
            padding: 6px;
            margin-top: 5px;
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            border: none;
            border-radius: 5px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s;
        }
        
        .sell-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
        }
        
        .close-popup-btn {
            position: absolute;
            top: 5px;
            right: 8px;
            background: none;
            border: none;
            color: #d4a84b;
            font-size: 18px;
            cursor: pointer;
        }
        
        /* Next Wave Button */
        .next-wave-btn {
            position: absolute;
            top: 70px;
            right: 15px;
            padding: 8px 15px;
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            border: 2px solid #e74c3c;
            border-radius: 20px;
            color: #fff;
            font-weight: bold;
            cursor: pointer;
            font-size: 12px;
            z-index: 60;
            transition: all 0.3s;
            display: none;
        }
        
        .next-wave-btn.show {
            display: block;
        }
        
        .next-wave-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(231, 76, 60, 0.6);
        }
        
        /* Responsive */
        @media (max-width: 600px) {
            .ui-header {
                gap: 10px;
                padding: 6px 12px;
                font-size: 12px;
                top: 10px;
            }
            
            .stat-box {
                font-size: 12px;
            }
            
            .tower-panel {
                gap: 5px;
                padding: 8px 10px;
                bottom: 10px;
            }
            
            .tower-btn {
                width: 50px;
                height: 50px;
            }
            
            .tower-icon {
                font-size: 18px;
            }
            
            .diff-btn {
                padding: 8px 18px;
                font-size: 12px;
            }
            
            .menu-btn {
                padding: 10px 30px;
                font-size: 16px;
                min-width: 160px;
            }
            
            .game-pause-btn,
            .back-home-btn {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }

            .back-home-btn {
                right: 60px;
            }
        }

        /* Wave announcement */
        .wave-announcement {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10000;
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            padding: 30px 50px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            text-align: center;
            opacity: 1;
            transition: opacity 0.5s;
        }

        .wave-title {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 10px;
            font-family: 'Cinzel', serif;
        }

        .wave-info {
            display: flex;
            flex-direction: column;
            gap: 8px;
            font-size: 18px;
        }

        @media (max-width: 768px) {
            .wave-announcement {
                width: 90%;
                padding: 20px 30px;
            }

            .wave-title {
                font-size: 24px;
            }

            .wave-info {
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        
        <div class="ui-header" id="gameUI" style="display: none;">
            <div class="stat-box">
                <span class="stat-label">â¤ï¸ ç”Ÿå‘½</span>
                <div class="hearts" id="livesDisplay">
                    <span class="heart">â¤</span>
                    <span class="heart">â¤</span>
                    <span class="heart">â¤</span>
                </div>
            </div>
            <div class="stat-box">
                <span class="stat-label">ğŸ’° é‡‘å¸</span>
                <span class="stat-value" id="goldDisplay">500</span>
            </div>
            <div class="stat-box">
                <span class="stat-label">ğŸŒŠ æ³¢æ¬¡</span>
                <span class="stat-value" id="waveDisplay">1</span>
            </div>
            <div class="stat-box">
                <span class="stat-label">ğŸ‘¹ æ•Œäºº</span>
                <span class="stat-value" id="enemyDisplay">0</span>
            </div>
        </div>
        
        <div class="pause-indicator" id="pauseIndicator">æš‚åœ</div>
        
        <div id="gameControls" style="display: none;">
            <button class="back-home-btn" id="backHomeBtn" title="è¿”å›ä¸»é¡µ">Ã—</button>
            <button class="game-pause-btn" id="gamePauseBtn" title="æš‚åœæ¸¸æˆ">â¸</button>
            <button class="next-wave-btn" id="nextWaveBtn">ğŸš€ ä¸‹ä¸€æ³¢</button>
        </div>
        
        <div class="tower-panel" id="towerPanel" style="display: none;">
            <div class="tower-btn" data-tower="rapid" title="æœºå…³ç‚®å¡” - å¿«é€Ÿå°„å‡»">
                <span class="tower-icon">ğŸ”«</span>
                <span class="tower-cost">50ğŸ’°</span>
                <span class="tower-name">æœºå…³ç‚®</span>
            </div>
            <div class="tower-btn" data-tower="cannon" title="åŠ å†œç‚®å¡” - èŒƒå›´ä¼¤å®³">
                <span class="tower-icon">ğŸ’£</span>
                <span class="tower-cost">100ğŸ’°</span>
                <span class="tower-name">åŠ å†œç‚®</span>
            </div>
            <div class="tower-btn" data-tower="ice" title="å¯’å†°å¡” - å‡é€Ÿæ•Œäºº">
                <span class="tower-icon">â„ï¸</span>
                <span class="tower-cost">80ğŸ’°</span>
                <span class="tower-name">å¯’å†°å¡”</span>
            </div>
            <div class="tower-btn" data-tower="laser" title="æ¿€å…‰å¡” - ç©¿é€æ”»å‡»">
                <span class="tower-icon">âš¡</span>
                <span class="tower-cost">150ğŸ’°</span>
                <span class="tower-name">æ¿€å…‰å¡”</span>
            </div>
            <div class="tower-btn" data-tower="gold" title="é‡‘å¸å¡” - äº§ç”Ÿé‡‘å¸">
                <span class="tower-icon">ğŸ’</span>
                <span class="tower-cost">200ğŸ’°</span>
                <span class="tower-name">é‡‘å¸å¡”</span>
            </div>
        </div>
        
        <!-- Tower Info Popup -->
        <div class="tower-info-popup" id="towerInfoPopup">
            <button class="close-popup-btn" id="closePopupBtn">Ã—</button>
            <div class="tower-info-title" id="popupTitle">ğŸ”« æœºå…³ç‚®å¡”</div>
            <div class="tower-info-stat">æ”»å‡»åŠ›: <span id="popupDamage">10</span></div>
            <div class="tower-info-stat">å°„ç¨‹: <span id="popupRange">3æ ¼</span></div>
            <div class="tower-info-stat">æ”»é€Ÿ: <span id="popupSpeed">å¿«</span></div>
            <div class="tower-info-stat">ç­‰çº§: <span id="popupLevel">1</span></div>
            <button class="upgrade-btn" id="upgradeBtn">
                â¬†ï¸ å‡çº§ (<span id="upgradeCost">100</span>ğŸ’°)
            </button>
            <button class="sell-btn" id="sellBtn">
                ğŸ’° å‡ºå”® (+<span id="sellPrice">25</span>ğŸ’°)
            </button>
        </div>
        
        <div class="pause-menu-overlay" id="pauseMenu">
            <h2 class="pause-menu-title">æ¸¸æˆæš‚åœ</h2>
            <div class="pause-menu-buttons">
                <button class="pause-menu-btn resume-btn" id="resumeBtn">ç»§ç»­æ¸¸æˆ</button>
                <button class="pause-menu-btn back-menu-btn" id="pauseBackMenuBtn">è¿”å›èœå•</button>
                <button class="pause-menu-btn home-btn" id="pauseHomeBtn">è¿”å›ä¸»é¡µ</button>
            </div>
        </div>
        
        <!-- Main Menu -->
        <div class="menu-overlay" id="mainMenu">
            <h1 class="game-title">ğŸ´â€â˜ ï¸ èˆªæµ·ç‹å¡”é˜²</h1>
            <p class="game-subtitle">å®ˆæŠ¤ä¼Ÿå¤§èˆªè·¯çš„å®è—</p>
            
            <div class="instructions">
                <h3>âš”ï¸ æ¸¸æˆè¯´æ˜</h3>
                <ul>
                    <li>ç‚¹å‡»ç©ºåœ°æ”¾ç½®é˜²å¾¡å¡”ï¼Œé˜»æ­¢æ•Œäººåˆ°è¾¾ç»ˆç‚¹</li>
                    <li>æ¶ˆç­æ•Œäººè·å¾—é‡‘å¸ï¼Œç”¨äºå»ºé€ å’Œå‡çº§å¡”</li>
                    <li>æ•Œäººåˆ°è¾¾ç»ˆç‚¹ä¼šæ‰£é™¤ç”Ÿå‘½ï¼Œç”Ÿå‘½å½’é›¶æ¸¸æˆç»“æŸ</li>
                    <li>ç‚¹å‡»å·²æ”¾ç½®çš„å¡”å¯æŸ¥çœ‹å±æ€§å’Œå‡çº§</li>
                </ul>
            </div>
            
            <div class="difficulty-section">
                <p class="difficulty-label">é€‰æ‹©éš¾åº¦</p>
                <div class="difficulty-buttons">
                    <button class="diff-btn active" data-diff="easy">ç®€å•</button>
                    <button class="diff-btn" data-diff="medium">ä¸­ç­‰</button>
                    <button class="diff-btn" data-diff="hard">å›°éš¾</button>
                </div>
            </div>
            
            <div class="menu-buttons">
                <button class="menu-btn start-btn" id="startBtn">å¼€å§‹æ¸¸æˆ</button>
                <button class="menu-btn home-btn" id="homeBtn">è¿”å›ä¸»é¡µ</button>
            </div>
            
            <div class="controls-hint">
                <p><span>ğŸ–±ï¸ ç‚¹å‡»</span> æ”¾ç½®é˜²å¾¡å¡”</p>
                <p>ç‚¹å‡»å·²æ”¾ç½®çš„å¡”è¿›è¡Œ<span>å‡çº§</span>æˆ–<span>å‡ºå”®</span></p>
            </div>
        </div>
        
        <!-- Game Over Menu -->
        <div class="menu-overlay hidden" id="gameOverMenu">
            <h2 class="game-over-title" id="gameOverTitle">æ¸¸æˆç»“æŸ</h2>
            <div class="final-stats">
                <div>ğŸ´â€â˜ ï¸ æœ€ç»ˆæ³¢æ¬¡: <span id="finalWave">1</span></div>
                <div>ğŸ’° è·å¾—é‡‘å¸: <span id="finalGold">0</span></div>
                <div>ğŸ‘¹ æ¶ˆç­æ•Œäºº: <span id="finalKills">0</span></div>
            </div>
            
            <div class="menu-buttons" id="gameOverButtons">
                <button class="menu-btn start-btn" id="restartBtn">é‡æ–°å¼€å§‹</button>
                <button class="menu-btn home-btn" id="menuBtn">è¿”å›èœå•</button>
                <button class="menu-btn home-btn" id="gameOverHomeBtn">è¿”å›ä¸»é¡µ</button>
            </div>
        </div>
    </div>

    <script>
        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Game state
        let gameState = 'menu'; // menu, playing, paused, gameover
        let difficulty = 'easy';
        let animationId = null;
        
        // Grid settings
        const GRID_SIZE = 12;
        let CELL_SIZE = 40;
        
        // Game variables
        let gold = 500;
        let lives = 20;
        let wave = 1;
        let enemiesKilled = 0;
        let selectedTowerType = null;
        let selectedTower = null;
        let showRange = false;
        let rangePosition = null;
        
        // Entities
        let towers = [];
        let enemies = [];
        let projectiles = [];
        let particles = [];
        let waveInProgress = false;
        let enemiesToSpawn = [];
        let spawnTimer = 0;
        let gameTime = 0;
        
        // Path definition (grid coordinates)
        let path = [];
        
        // Difficulty settings
        const difficultySettings = {
            easy: { initialGold: 600, enemyHealthMult: 0.8, enemySpeedMult: 0.9 },
            medium: { initialGold: 500, enemyHealthMult: 1.0, enemySpeedMult: 1.0 },
            hard: { initialGold: 400, enemyHealthMult: 1.3, enemySpeedMult: 1.2 }
        };
        
        // Tower types
        const towerTypes = {
            rapid: {
                name: 'æœºå…³ç‚®å¡”',
                icon: 'ğŸ”«',
                cost: 50,
                damage: 8,
                range: 2.5,
                fireRate: 8, // shots per second
                color: '#3498db',
                projectileSpeed: 8,
                description: 'å¿«é€Ÿå°„å‡»ï¼Œå•ä½“ä¼¤å®³'
            },
            cannon: {
                name: 'åŠ å†œç‚®å¡”',
                icon: 'ğŸ’£',
                cost: 100,
                damage: 25,
                range: 2,
                fireRate: 1.5,
                color: '#e74c3c',
                projectileSpeed: 5,
                splashRadius: 1.5,
                description: 'èŒƒå›´ä¼¤å®³ï¼Œçˆ†ç‚¸æ•ˆæœ'
            },
            ice: {
                name: 'å¯’å†°å¡”',
                icon: 'â„ï¸',
                cost: 80,
                damage: 3,
                range: 2.5,
                fireRate: 2,
                color: '#00ced1',
                projectileSpeed: 6,
                slowFactor: 0.5,
                slowDuration: 120,
                description: 'å‡é€Ÿæ•Œäººï¼Œè¾…åŠ©æ§åˆ¶'
            },
            laser: {
                name: 'æ¿€å…‰å¡”',
                icon: 'âš¡',
                cost: 150,
                damage: 5,
                range: 4,
                fireRate: 10,
                color: '#9b59b6',
                projectileSpeed: 20,
                pierce: true,
                description: 'ç©¿é€æ”»å‡»ï¼Œè¿œç¨‹è¾“å‡º'
            },
            gold: {
                name: 'é‡‘å¸å¡”',
                icon: 'ğŸ’',
                cost: 200,
                damage: 0,
                range: 0,
                fireRate: 0,
                color: '#ffd700',
                goldGeneration: 15,
                goldInterval: 180, // frames
                description: 'å®šæœŸäº§ç”Ÿé‡‘å¸'
            }
        };
        
        // Enemy types
        const enemyTypes = {
            normal: {
                name: 'æ™®é€šæµ·ç›—',
                health: 30,
                speed: 1.5,
                reward: 8,
                color: '#e74c3c',
                radius: 12
            },
            fast: {
                name: 'å¿«é€Ÿæµ·ç›—',
                health: 15,
                speed: 2.5,
                reward: 12,
                color: '#f39c12',
                radius: 10
            },
            tank: {
                name: 'é‡è£…æµ·ç›—',
                health: 80,
                speed: 0.8,
                reward: 25,
                color: '#8e44ad',
                radius: 15
            },
            flying: {
                name: 'é£è¡Œæµ·ç›—',
                health: 25,
                speed: 2.0,
                reward: 20,
                color: '#3498db',
                radius: 11,
                flying: true
            },
            boss: {
                name: 'æµ·ç›—èˆ¹é•¿',
                health: 300,
                speed: 0.5,
                reward: 100,
                color: '#c0392b',
                radius: 20,
                boss: true
            }
        };
        
        // Wave configurations
        function generateWave(waveNum) {
            const waves = [];
            const diff = difficultySettings[difficulty];
            
            // Normal waves
            if (waveNum % 5 !== 0) {
                const enemyCount = 5 + waveNum * 2;
                for (let i = 0; i < enemyCount; i++) {
                    if (waveNum >= 3 && i % 5 === 0) {
                        waves.push('fast');
                    } else if (waveNum >= 5 && i % 7 === 0) {
                        waves.push('tank');
                    } else if (waveNum >= 7 && i % 10 === 0) {
                        waves.push('flying');
                    } else {
                        waves.push('normal');
                    }
                }
            } else {
                // Boss wave every 5 waves
                waves.push('boss');
                for (let i = 0; i < 5 + waveNum; i++) {
                    waves.push('normal');
                }
                waves.push('boss');
            }
            
            return waves;
        }
        
        // Initialize path
        function initPath() {
            // Create a winding path through the grid
            path = [
                {x: 0, y: 2},
                {x: 3, y: 2},
                {x: 3, y: 6},
                {x: 7, y: 6},
                {x: 7, y: 3},
                {x: 10, y: 3},
                {x: 10, y: 8},
                {x: 5, y: 8},
                {x: 5, y: 10},
                {x: 11, y: 10}
            ];
        }
        
        // Resize canvas
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const maxWidth = Math.min(800, container.clientWidth - 20);
            const maxHeight = Math.min(600, window.innerHeight - 200);
            
            const size = Math.min(maxWidth, maxHeight);
            CELL_SIZE = Math.floor(size / GRID_SIZE);
            
            canvas.width = CELL_SIZE * GRID_SIZE;
            canvas.height = CELL_SIZE * GRID_SIZE;
        }
        
        // Grid coordinates to pixel coordinates
        function gridToPixel(gx, gy) {
            return {
                x: gx * CELL_SIZE + CELL_SIZE / 2,
                y: gy * CELL_SIZE + CELL_SIZE / 2
            };
        }
        
        // Pixel coordinates to grid coordinates
        function pixelToGrid(px, py) {
            return {
                x: Math.floor(px / CELL_SIZE),
                y: Math.floor(py / CELL_SIZE)
            };
        }
        
        // Check if position is on path
        function isPath(gx, gy) {
            for (let i = 0; i < path.length - 1; i++) {
                const p1 = path[i];
                const p2 = path[i + 1];
                
                // Check if point is on this path segment
                if (p1.x === p2.x) {
                    // Vertical segment
                    if (gx === p1.x && gy >= Math.min(p1.y, p2.y) && gy <= Math.max(p1.y, p2.y)) {
                        return true;
                    }
                } else if (p1.y === p2.y) {
                    // Horizontal segment
                    if (gy === p1.y && gx >= Math.min(p1.x, p2.x) && gx <= Math.max(p1.x, p2.x)) {
                        return true;
                    }
                }
            }
            return false;
        }
        
        // Check if tower exists at position
        function getTowerAt(gx, gy) {
            return towers.find(t => t.gridX === gx && t.gridY === gy);
        }
        
        // Can place tower at position
        function canPlaceTower(gx, gy) {
            if (gx < 0 || gx >= GRID_SIZE || gy < 0 || gy >= GRID_SIZE) return false;
            if (isPath(gx, gy)) return false;
            if (getTowerAt(gx, gy)) return false;
            return true;
        }
        
        // Create enemy
        function createEnemy(type) {
            const enemyType = enemyTypes[type];
            const diff = difficultySettings[difficulty];
            const startPos = gridToPixel(path[0].x, path[0].y);
            
            return {
                type: type,
                x: startPos.x,
                y: startPos.y,
                gridX: path[0].x,
                gridY: path[0].y,
                pathIndex: 0,
                health: enemyType.health * diff.enemyHealthMult * (1 + (wave - 1) * 0.15),
                maxHealth: enemyType.health * diff.enemyHealthMult * (1 + (wave - 1) * 0.15),
                speed: enemyType.speed * diff.enemySpeedMult * CELL_SIZE / 60,
                reward: enemyType.reward,
                color: enemyType.color,
                radius: enemyType.radius * (CELL_SIZE / 40),
                flying: enemyType.flying || false,
                boss: enemyType.boss || false,
                slowTimer: 0,
                frozen: false,
                effects: []
            };
        }
        
        // Create projectile
        function createProjectile(tower, target, targetX, targetY) {
            const tType = towerTypes[tower.type];
            const angle = Math.atan2(targetY - tower.y, targetX - tower.x);
            
            return {
                x: tower.x,
                y: tower.y,
                vx: Math.cos(angle) * tType.projectileSpeed * (CELL_SIZE / 40),
                vy: Math.sin(angle) * tType.projectileSpeed * (CELL_SIZE / 40),
                damage: tType.damage * tower.level,
                speed: tType.projectileSpeed,
                color: tType.color,
                target: target,
                type: tower.type,
                splashRadius: tType.splashRadius || 0,
                slowFactor: tType.slowFactor || 0,
                slowDuration: tType.slowDuration || 0,
                pierce: tType.pierce || false,
                pierced: []
            };
        }
        
        // Create particle
        function createParticles(x, y, color, count = 5) {
            for (let i = 0; i < count; i++) {
                const angle = (Math.PI * 2 * i) / count;
                particles.push({
                    x: x,
                    y: y,
                    vx: Math.cos(angle) * (Math.random() * 2 + 1),
                    vy: Math.sin(angle) * (Math.random() * 2 + 1),
                    life: 30 + Math.random() * 20,
                    maxLife: 30 + Math.random() * 20,
                    color: color,
                    size: Math.random() * 4 + 2
                });
            }
        }
        
        // Create floating text
        function createFloatingText(x, y, text, color) {
            particles.push({
                x: x,
                y: y,
                vx: 0,
                vy: -1,
                life: 40,
                maxLife: 40,
                text: text,
                color: color,
                isText: true
            });
        }
        
        // Start wave
        function startWave() {
            if (waveInProgress) return;
            
            enemiesToSpawn = generateWave(wave);
            waveInProgress = true;
            spawnTimer = 0;
            document.getElementById('nextWaveBtn').classList.remove('show');
        }

        // Show wave announcement
        function showWaveAnnouncement(waveNum) {
            const announcement = document.createElement('div');
            announcement.className = 'wave-announcement';
            announcement.innerHTML = `
                <div class="wave-content">
                    <div class="wave-title">ğŸŒŠ ç¬¬ ${waveNum} æ³¢</div>
                    <div class="wave-info">
                        <span>â±ï¸ 3ç§’åå¼€å§‹</span>
                    </div>
                </div>
            `;
            document.body.appendChild(announcement);

            setTimeout(() => {
                announcement.style.opacity = '0';
                setTimeout(() => {
                    announcement.remove();
                }, 500);
            }, 2500);
        }

        // Update game
        function update() {
            if (gameState !== 'playing') return;
            
            gameTime++;
            
            // Spawn enemies
            if (waveInProgress && enemiesToSpawn.length > 0) {
                spawnTimer++;
                if (spawnTimer >= 40) { // Spawn every 40 frames
                    const type = enemiesToSpawn.shift();
                    enemies.push(createEnemy(type));
                    spawnTimer = 0;
                }
            }
            
            // Check wave end
            if (waveInProgress && enemiesToSpawn.length === 0 && enemies.length === 0) {
                waveInProgress = false;

                // Bonus gold for completing wave
                gold += 50 + wave * 10;

                // Auto start next wave after 3 seconds
                setTimeout(() => {
                    if (gameState === 'playing') {
                        wave++;
                        updateUI();
                        startWave();
                    }
                }, 3000);

                // Show wave announcement
                showWaveAnnouncement(wave + 1);
                updateUI();
            }
            
            // Update towers
            towers.forEach(tower => {
                const tType = towerTypes[tower.type];
                
                // Gold generation
                if (tower.type === 'gold') {
                    tower.goldTimer++;
                    if (tower.goldTimer >= tType.goldInterval) {
                        gold += tType.goldGeneration * tower.level;
                        tower.goldTimer = 0;
                        createFloatingText(tower.x, tower.y - 20, `+${tType.goldGeneration * tower.level}`, '#ffd700');
                        updateUI();
                    }
                    return;
                }
                
                // Find target
                tower.fireCooldown--;
                
                if (tower.fireCooldown <= 0) {
                    let target = null;
                    let minDistance = Infinity;
                    
                    // Find enemy in range
                    for (const enemy of enemies) {
                        const dx = enemy.x - tower.x;
                        const dy = enemy.y - tower.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const range = tType.range * CELL_SIZE;
                        
                        if (distance <= range && distance < minDistance) {
                            minDistance = distance;
                            target = enemy;
                        }
                    }
                    
                    if (target) {
                        projectiles.push(createProjectile(tower, target, target.x, target.y));
                        tower.fireCooldown = 60 / tType.fireRate;
                        
                        // Recoil animation
                        tower.recoil = 5;
                    }
                }
                
                if (tower.recoil > 0) tower.recoil *= 0.9;
            });
            
            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Apply slow effect
                let currentSpeed = enemy.speed;
                if (enemy.slowTimer > 0) {
                    currentSpeed *= 0.5;
                    enemy.slowTimer--;
                }
                
                // Move along path
                const targetGrid = path[enemy.pathIndex + 1];
                if (targetGrid) {
                    const targetPos = gridToPixel(targetGrid.x, targetGrid.y);
                    const dx = targetPos.x - enemy.x;
                    const dy = targetPos.y - enemy.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < currentSpeed) {
                        enemy.x = targetPos.x;
                        enemy.y = targetPos.y;
                        enemy.pathIndex++;
                        enemy.gridX = targetGrid.x;
                        enemy.gridY = targetGrid.y;
                        
                        if (enemy.pathIndex >= path.length - 1) {
                            // Enemy reached end
                            lives--;
                            createParticles(enemy.x, enemy.y, '#e74c3c', 8);
                            enemies.splice(i, 1);
                            updateUI();
                            
                            if (lives <= 0) {
                                gameOver();
                            }
                            continue;
                        }
                    } else {
                        enemy.x += (dx / distance) * currentSpeed;
                        enemy.y += (dy / distance) * currentSpeed;
                    }
                }
                
                // Apply effects
                enemy.effects = enemy.effects.filter(effect => {
                    effect.duration--;
                    return effect.duration > 0;
                });
            }
            
            // Update projectiles
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const proj = projectiles[i];
                
                proj.x += proj.vx;
                proj.y += proj.vy;
                
                // Check bounds
                if (proj.x < 0 || proj.x > canvas.width || proj.y < 0 || proj.y > canvas.height) {
                    projectiles.splice(i, 1);
                    continue;
                }
                
                // Check collision with enemies
                let hit = false;
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const enemy = enemies[j];
                    const dx = enemy.x - proj.x;
                    const dy = enemy.y - proj.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Check if already pierced this enemy
                    if (proj.pierce && proj.pierced.includes(enemy)) continue;
                    
                    if (distance < enemy.radius + 5) {
                        // Hit enemy
                        hit = true;
                        
                        if (proj.slowFactor > 0) {
                            enemy.slowTimer = proj.slowDuration;
                        }
                        
                        // Splash damage
                        if (proj.splashRadius > 0) {
                            createParticles(proj.x, proj.y, proj.color, 10);
                            for (const otherEnemy of enemies) {
                                const odx = otherEnemy.x - proj.x;
                                const ody = otherEnemy.y - proj.y;
                                const odist = Math.sqrt(odx * odx + ody * ody);
                                if (odist < proj.splashRadius * CELL_SIZE) {
                                    otherEnemy.health -= proj.damage * (1 - odist / (proj.splashRadius * CELL_SIZE));
                                }
                            }
                        } else {
                            enemy.health -= proj.damage;
                            if (!proj.pierce) createParticles(proj.x, proj.y, proj.color, 3);
                        }
                        
                        if (proj.pierce) {
                            proj.pierced.push(enemy);
                            hit = false; // Continue flying
                        }
                        
                        // Check enemy death
                        if (enemy.health <= 0) {
                            gold += enemy.reward;
                            enemiesKilled++;
                            createParticles(enemy.x, enemy.y, enemy.color, 8);
                            createFloatingText(enemy.x, enemy.y, `+${enemy.reward}ğŸ’°`, '#ffd700');
                            enemies.splice(j, 1);
                            updateUI();
                        }
                        
                        if (!proj.pierce) break;
                    }
                }
                
                if (hit && !proj.pierce) {
                    projectiles.splice(i, 1);
                } else if (proj.pierce && proj.pierced.length > 3) {
                    projectiles.splice(i, 1);
                }
            }
            
            // Update particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                
                if (p.life <= 0) {
                    particles.splice(i, 1);
                }
            }
        }
        
        // Draw functions
        function draw() {
            // Clear canvas
            ctx.fillStyle = '#0d2137';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            ctx.strokeStyle = 'rgba(212, 168, 75, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CELL_SIZE, 0);
                ctx.lineTo(i * CELL_SIZE, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * CELL_SIZE);
                ctx.lineTo(canvas.width, i * CELL_SIZE);
                ctx.stroke();
            }
            
            // Draw path
            ctx.fillStyle = 'rgba(139, 69, 19, 0.3)';
            for (let i = 0; i < path.length - 1; i++) {
                const p1 = path[i];
                const p2 = path[i + 1];
                
                if (p1.x === p2.x) {
                    const y1 = Math.min(p1.y, p2.y) * CELL_SIZE;
                    const y2 = (Math.max(p1.y, p2.y) + 1) * CELL_SIZE;
                    ctx.fillRect(p1.x * CELL_SIZE, y1, CELL_SIZE, y2 - y1);
                } else {
                    const x1 = Math.min(p1.x, p2.x) * CELL_SIZE;
                    const x2 = (Math.max(p1.x, p2.x) + 1) * CELL_SIZE;
                    ctx.fillRect(x1, p1.y * CELL_SIZE, x2 - x1, CELL_SIZE);
                }
            }
            
            // Draw path borders
            ctx.strokeStyle = 'rgba(212, 168, 75, 0.3)';
            ctx.lineWidth = 2;
            for (let i = 0; i < path.length - 1; i++) {
                const p1 = path[i];
                const p2 = path[i + 1];
                
                ctx.beginPath();
                if (p1.x === p2.x) {
                    const x = p1.x * CELL_SIZE + CELL_SIZE / 2;
                    const y1 = Math.min(p1.y, p2.y) * CELL_SIZE;
                    const y2 = (Math.max(p1.y, p2.y) + 1) * CELL_SIZE;
                    ctx.moveTo(x, y1);
                    ctx.lineTo(x, y2);
                } else {
                    const y = p1.y * CELL_SIZE + CELL_SIZE / 2;
                    const x1 = Math.min(p1.x, p2.x) * CELL_SIZE;
                    const x2 = (Math.max(p1.x, p2.x) + 1) * CELL_SIZE;
                    ctx.moveTo(x1, y);
                    ctx.lineTo(x2, y);
                }
                ctx.stroke();
            }
            
            // Draw start and end markers
            const startPos = gridToPixel(path[0].x, path[0].y);
            const endPos = gridToPixel(path[path.length - 1].x, path[path.length - 1].y);
            
            ctx.fillStyle = '#2ecc71';
            ctx.beginPath();
            ctx.arc(startPos.x, startPos.y, CELL_SIZE * 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.font = `${CELL_SIZE * 0.3}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('ğŸ´â€â˜ ï¸', startPos.x, startPos.y);
            
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(endPos.x, endPos.y, CELL_SIZE * 0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.fillText('ğŸ’', endPos.x, endPos.y);
            
            // Draw range indicator
            if (showRange && rangePosition) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                let range = selectedTowerType ? towerTypes[selectedTowerType].range * CELL_SIZE : 0;
                if (selectedTower) {
                    range = towerTypes[selectedTower.type].range * CELL_SIZE;
                }
                ctx.arc(rangePosition.x, rangePosition.y, range, 0, Math.PI * 2);
                ctx.fill();
                ctx.stroke();
            }
            
            // Draw valid placement indicator
            if (selectedTowerType && rangePosition) {
                const grid = pixelToGrid(rangePosition.x, rangePosition.y);
                const valid = canPlaceTower(grid.x, grid.y);
                const pixel = gridToPixel(grid.x, grid.y);
                
                ctx.fillStyle = valid ? 'rgba(46, 204, 113, 0.3)' : 'rgba(231, 76, 60, 0.3)';
                ctx.fillRect(grid.x * CELL_SIZE, grid.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
            }
            
            // Draw towers
            towers.forEach(tower => {
                const tType = towerTypes[tower.type];
                
                // Base
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(tower.x, tower.y + 5, CELL_SIZE * 0.35, 0, Math.PI * 2);
                ctx.fill();
                
                // Tower body
                const recoil = tower.recoil || 0;
                const gradient = ctx.createRadialGradient(
                    tower.x - 5, tower.y - 5, 0,
                    tower.x, tower.y, CELL_SIZE * 0.35
                );
                gradient.addColorStop(0, tType.color);
                gradient.addColorStop(1, darkenColor(tType.color, 30));
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(tower.x, tower.y - recoil, CELL_SIZE * 0.35, 0, Math.PI * 2);
                ctx.fill();
                
                // Border
                ctx.strokeStyle = '#d4a84b';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(tower.x, tower.y - recoil, CELL_SIZE * 0.35, 0, Math.PI * 2);
                ctx.stroke();
                
                // Level indicator
                if (tower.level > 1) {
                    ctx.fillStyle = '#ffd700';
                    ctx.font = `bold ${CELL_SIZE * 0.2}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(tower.level, tower.x, tower.y - recoil);
                }
                
                // Selection highlight
                if (selectedTower === tower) {
                    ctx.strokeStyle = '#ffd700';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.arc(tower.x, tower.y, CELL_SIZE * 0.45, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            });
            
            // Draw enemies
            enemies.forEach(enemy => {
                const eType = enemyTypes[enemy.type];
                
                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(enemy.x, enemy.y + enemy.radius * 0.5, enemy.radius, enemy.radius * 0.5, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Body
                ctx.fillStyle = enemy.color;
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Border
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(enemy.x, enemy.y, enemy.radius, 0, Math.PI * 2);
                ctx.stroke();
                
                // Flying indicator
                if (enemy.flying) {
                    ctx.fillStyle = '#87ceeb';
                    ctx.font = `${enemy.radius}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('âœˆï¸', enemy.x, enemy.y);
                }
                
                // Boss indicator
                if (enemy.boss) {
                    ctx.fillStyle = '#ffd700';
                    ctx.font = `bold ${enemy.radius * 0.8}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('ğŸ‘‘', enemy.x, enemy.y);
                }
                
                // Health bar
                const barWidth = enemy.radius * 2;
                const barHeight = 4;
                const healthPercent = enemy.health / enemy.maxHealth;
                
                ctx.fillStyle = '#333';
                ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemy.radius - 8, barWidth, barHeight);
                
                ctx.fillStyle = healthPercent > 0.5 ? '#2ecc71' : healthPercent > 0.25 ? '#f39c12' : '#e74c3c';
                ctx.fillRect(enemy.x - barWidth / 2, enemy.y - enemy.radius - 8, barWidth * healthPercent, barHeight);
                
                // Slow effect
                if (enemy.slowTimer > 0) {
                    ctx.strokeStyle = '#00ced1';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(enemy.x, enemy.y, enemy.radius + 3, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });
            
            // Draw projectiles
            projectiles.forEach(proj => {
                ctx.fillStyle = proj.color;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Glow effect
                ctx.shadowColor = proj.color;
                ctx.shadowBlur = 10;
                ctx.beginPath();
                ctx.arc(proj.x, proj.y, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            });
            
            // Draw particles
            particles.forEach(p => {
                const alpha = p.life / p.maxLife;
                
                if (p.isText) {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = alpha;
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(p.text, p.x, p.y);
                    ctx.globalAlpha = 1;
                } else {
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = alpha;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            });
        }
        
        // Helper function to darken color
        function darkenColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) - amt;
            const G = (num >> 8 & 0x00FF) - amt;
            const B = (num & 0x0000FF) - amt;
            return '#' + (0x1000000 + (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255))
                .toString(16).slice(1);
        }
        
        // Game loop
        function gameLoop() {
            update();
            draw();
            animationId = requestAnimationFrame(gameLoop);
        }
        
        // Start game
        function startGame() {
            const diff = difficultySettings[difficulty];
            
            gameState = 'playing';
            gold = diff.initialGold;
            lives = 20;
            wave = 1;
            enemiesKilled = 0;
            
            towers = [];
            enemies = [];
            projectiles = [];
            particles = [];
            waveInProgress = false;
            enemiesToSpawn = [];
            selectedTowerType = null;
            selectedTower = null;
            
            document.getElementById('mainMenu').classList.add('hidden');
            document.getElementById('gameOverMenu').classList.add('hidden');
            document.getElementById('gameUI').style.display = 'flex';
            document.getElementById('gameControls').style.display = 'block';
            document.getElementById('towerPanel').style.display = 'flex';
            document.getElementById('pauseIndicator').style.display = 'none';
            document.getElementById('nextWaveBtn').classList.add('show');
            
            resizeCanvas();
            initPath();
            updateUI();
            
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            gameLoop();
        }
        
        // Game over
        function gameOver() {
            gameState = 'gameover';
            document.getElementById('gameOverTitle').textContent = 'æ¸¸æˆç»“æŸ';
            document.getElementById('gameOverTitle').classList.remove('victory-title');
            document.getElementById('finalWave').textContent = wave;
            document.getElementById('finalGold').textContent = gold;
            document.getElementById('finalKills').textContent = enemiesKilled;
            document.getElementById('gameOverMenu').classList.remove('hidden');
            document.getElementById('gameControls').style.display = 'none';
            document.getElementById('towerPanel').style.display = 'none';
        }
        
        // Update UI
        function updateUI() {
            document.getElementById('goldDisplay').textContent = gold;
            document.getElementById('waveDisplay').textContent = wave;
            document.getElementById('enemyDisplay').textContent = enemies.length;
            
            const heartsContainer = document.getElementById('livesDisplay');
            heartsContainer.innerHTML = '';
            const maxHearts = 10;
            const fullHearts = Math.min(lives, maxHearts);
            for (let i = 0; i < maxHearts; i++) {
                const heart = document.createElement('span');
                heart.className = 'heart' + (i >= lives ? ' lost' : '');
                heart.textContent = 'â¤';
                heartsContainer.appendChild(heart);
            }
            
            // Update tower buttons
            document.querySelectorAll('.tower-btn').forEach(btn => {
                const towerType = btn.dataset.tower;
                const cost = towerTypes[towerType].cost;
                if (gold < cost) {
                    btn.classList.add('disabled');
                } else {
                    btn.classList.remove('disabled');
                }
                
                if (selectedTowerType === towerType) {
                    btn.classList.add('selected');
                } else {
                    btn.classList.remove('selected');
                }
            });
        }
        
        // Canvas mouse events
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            rangePosition = {x, y};
            showRange = selectedTowerType !== null || selectedTower !== null;
        });
        
        canvas.addEventListener('mouseleave', () => {
            showRange = false;
            rangePosition = null;
        });
        
        canvas.addEventListener('click', (e) => {
            if (gameState !== 'playing') return;
            
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const grid = pixelToGrid(x, y);
            
            // Check if clicked on existing tower
            const clickedTower = getTowerAt(grid.x, grid.y);
            if (clickedTower) {
                selectedTower = clickedTower;
                selectedTowerType = null;
                showTowerInfo(clickedTower);
                updateUI();
                return;
            }
            
            // Hide tower info if clicking elsewhere
            hideTowerInfo();
            selectedTower = null;
            
            // Place new tower
            if (selectedTowerType && canPlaceTower(grid.x, grid.y)) {
                const tType = towerTypes[selectedTowerType];
                if (gold >= tType.cost) {
                    gold -= tType.cost;
                    const pos = gridToPixel(grid.x, grid.y);
                    
                    const newTower = {
                        type: selectedTowerType,
                        x: pos.x,
                        y: pos.y,
                        gridX: grid.x,
                        gridY: grid.y,
                        level: 1,
                        fireCooldown: 0,
                        recoil: 0,
                        goldTimer: 0
                    };
                    
                    towers.push(newTower);
                    createParticles(pos.x, pos.y, tType.color, 5);
                    updateUI();
                    
                    // Deselect after placing
                    selectedTowerType = null;
                    showRange = false;
                }
            }
        });
        
        // Show tower info popup
        function showTowerInfo(tower) {
            const popup = document.getElementById('towerInfoPopup');
            const tType = towerTypes[tower.type];
            
            document.getElementById('popupTitle').textContent = `${tType.icon} ${tType.name}`;
            document.getElementById('popupDamage').textContent = Math.floor(tType.damage * tower.level);
            document.getElementById('popupRange').textContent = tType.range + 'æ ¼';
            document.getElementById('popupSpeed').textContent = tType.fireRate > 5 ? 'å¿«' : tType.fireRate > 2 ? 'ä¸­' : 'æ…¢';
            document.getElementById('popupLevel').textContent = tower.level;
            
            const upgradeCost = Math.floor(tType.cost * 0.7 * tower.level);
            document.getElementById('upgradeCost').textContent = upgradeCost;
            
            const sellPrice = Math.floor(tType.cost * 0.5 * tower.level * 0.8);
            document.getElementById('sellPrice').textContent = sellPrice;
            
            const upgradeBtn = document.getElementById('upgradeBtn');
            if (gold >= upgradeCost) {
                upgradeBtn.classList.remove('disabled');
            } else {
                upgradeBtn.classList.add('disabled');
            }
            
            // Position popup near tower
            const rect = canvas.getBoundingClientRect();
            const pixel = gridToPixel(tower.gridX, tower.gridY);
            popup.style.left = (rect.left + pixel.x + CELL_SIZE) + 'px';
            popup.style.top = (rect.top + pixel.y - 50) + 'px';
            popup.classList.add('show');
            
            // Store current tower for buttons
            popup.dataset.towerX = tower.gridX;
            popup.dataset.towerY = tower.gridY;
        }
        
        // Hide tower info popup
        function hideTowerInfo() {
            document.getElementById('towerInfoPopup').classList.remove('show');
        }
        
        // Tower button events
        document.querySelectorAll('.tower-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (btn.classList.contains('disabled')) return;
                
                const towerType = btn.dataset.tower;
                if (selectedTowerType === towerType) {
                    selectedTowerType = null;
                } else {
                    selectedTowerType = towerType;
                    selectedTower = null;
                    hideTowerInfo();
                }
                updateUI();
            });
        });
        
        // Upgrade button
        document.getElementById('upgradeBtn').addEventListener('click', () => {
            const popup = document.getElementById('towerInfoPopup');
            const x = parseInt(popup.dataset.towerX);
            const y = parseInt(popup.dataset.towerY);
            const tower = getTowerAt(x, y);
            
            if (tower) {
                const tType = towerTypes[tower.type];
                const upgradeCost = Math.floor(tType.cost * 0.7 * tower.level);
                
                if (gold >= upgradeCost) {
                    gold -= upgradeCost;
                    tower.level++;
                    createParticles(tower.x, tower.y, '#ffd700', 8);
                    createFloatingText(tower.x, tower.y - 20, 'â¬†ï¸ å‡çº§!', '#ffd700');
                    updateUI();
                    showTowerInfo(tower);
                }
            }
        });
        
        // Sell button
        document.getElementById('sellBtn').addEventListener('click', () => {
            const popup = document.getElementById('towerInfoPopup');
            const x = parseInt(popup.dataset.towerX);
            const y = parseInt(popup.dataset.towerY);
            const towerIndex = towers.findIndex(t => t.gridX === x && t.gridY === y);
            
            if (towerIndex >= 0) {
                const tower = towers[towerIndex];
                const tType = towerTypes[tower.type];
                const sellPrice = Math.floor(tType.cost * 0.5 * tower.level * 0.8);
                
                gold += sellPrice;
                createParticles(tower.x, tower.y, '#e74c3c', 6);
                createFloatingText(tower.x, tower.y - 20, `+${sellPrice}ğŸ’°`, '#ffd700');
                
                towers.splice(towerIndex, 1);
                hideTowerInfo();
                selectedTower = null;
                updateUI();
            }
        });
        
        // Close popup button
        document.getElementById('closePopupBtn').addEventListener('click', hideTowerInfo);
        
        // Next wave button
        document.getElementById('nextWaveBtn').addEventListener('click', startWave);
        
        // Menu button events
        document.getElementById('startBtn').addEventListener('click', startGame);
        document.getElementById('restartBtn').addEventListener('click', startGame);
        document.getElementById('menuBtn').addEventListener('click', () => {
            document.getElementById('gameOverMenu').classList.add('hidden');
            document.getElementById('mainMenu').classList.remove('hidden');
            document.getElementById('gameUI').style.display = 'none';
            document.getElementById('gameControls').style.display = 'none';
            document.getElementById('towerPanel').style.display = 'none';
            gameState = 'menu';
        });
        
        document.getElementById('homeBtn').addEventListener('click', () => {
            window.location.href = '../index.html';
        });
        
        // Difficulty buttons
        document.querySelectorAll('.diff-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.diff-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                difficulty = btn.dataset.diff;
            });
        });
        
        // Pause menu functions
        function showPauseMenu() {
            if (gameState === 'playing') {
                gameState = 'paused';
                document.getElementById('pauseMenu').classList.add('show');
                document.getElementById('pauseIndicator').style.display = 'none';
            }
        }
        
        function hidePauseMenu() {
            document.getElementById('pauseMenu').classList.remove('show');
        }
        
        function resumeGame() {
            hidePauseMenu();
            gameState = 'playing';
        }
        
        function backToMenu() {
            hidePauseMenu();
            hideTowerInfo();
            document.getElementById('gameControls').style.display = 'none';
            document.getElementById('gameUI').style.display = 'none';
            document.getElementById('towerPanel').style.display = 'none';
            document.getElementById('mainMenu').classList.remove('hidden');
            gameState = 'menu';
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
        }
        
        function goBackHome() {
            if (gameState === 'playing') {
                const confirmMsg = 'ç¡®å®šè¦é€€å‡ºæ¸¸æˆå—ï¼Ÿå½“å‰è¿›åº¦å°†ä¸¢å¤±ã€‚';
                if (confirm(confirmMsg)) {
                    window.location.href = '../index.html';
                }
            } else {
                window.location.href = '../index.html';
            }
        }
        
        // Additional event listeners
        document.getElementById('gamePauseBtn').addEventListener('click', showPauseMenu);
        document.getElementById('backHomeBtn').addEventListener('click', goBackHome);
        document.getElementById('resumeBtn').addEventListener('click', resumeGame);
        document.getElementById('pauseBackMenuBtn').addEventListener('click', backToMenu);
        document.getElementById('pauseHomeBtn').addEventListener('click', goBackHome);
        document.getElementById('gameOverHomeBtn').addEventListener('click', goBackHome);
        
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ' || e.key === 'Spacebar') {
                if (gameState === 'playing' || gameState === 'paused') {
                    showPauseMenu();
                }
            } else if (e.key === 'Escape') {
                if (gameState === 'playing') {
                    showPauseMenu();
                } else if (gameState === 'paused') {
                    resumeGame();
                }
            }
        });
        
        // Window resize
        window.addEventListener('resize', () => {
            if (gameState === 'playing' || gameState === 'paused') {
                resizeCanvas();
            }
        });
        
        // Initialize
        resizeCanvas();
        initPath();
        draw();
    </script>
</body>
</html>
